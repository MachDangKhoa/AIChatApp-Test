"""
image_service.py
----------------
Handles image saving, validation, and preprocessing for image chat.
"""

import os
from pathlib import Path
from fastapi import UploadFile, HTTPException
from datetime import datetime
from PIL import Image, UnidentifiedImageError
import shutil
from services.gemini_service import get_model


# Directory to store temporary uploaded images
UPLOAD_DIR = Path("data/temp_uploads")

# Allowed file extensions and content types
ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png"}
ALLOWED_CONTENT_TYPES = {"image/jpeg", "image/png"}
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB limit


def save_uploaded_image(file: UploadFile) -> str:
    """
    Save an uploaded image temporarily and validate that it's a valid image file.

    Args:
        file (UploadFile): Uploaded file (expected to be PNG or JPG).

    Returns:
        str: Absolute path to the saved image file.

    Raises:
        HTTPException: If the file is invalid, too large, or not an image.
    """
    try:
        # ✅ Validate file extension
        file_extension = Path(file.filename).suffix.lower()
        if file_extension not in ALLOWED_EXTENSIONS:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid file extension. Only {', '.join(ALLOWED_EXTENSIONS)} are allowed."
            )

        # ✅ Validate content type
        if file.content_type not in ALLOWED_CONTENT_TYPES:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid content type. Only {', '.join(ALLOWED_CONTENT_TYPES)} are allowed."
            )

        # ✅ Validate file size
        file.file.seek(0, os.SEEK_END)
        file_size = file.file.tell()
        if file_size > MAX_FILE_SIZE:
            raise HTTPException(
                status_code=400,
                detail=f"File too large. Maximum size is {MAX_FILE_SIZE / (1024 * 1024)} MB."
            )
        if file_size == 0:
            raise HTTPException(status_code=400, detail="Uploaded file is empty.")
        file.file.seek(0)  # Reset file pointer to start

        # ✅ Ensure upload directory exists
        UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

        # ✅ Generate unique filename to avoid collisions
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        file_path = UPLOAD_DIR / f"{timestamp}_{file.filename}"

        # ✅ Save the file using shutil for reliable copying
        with open(file_path, "wb") as f:
            shutil.copyfileobj(file.file, f)

        # ✅ Validate the image using Pillow
        try:
            with Image.open(file_path) as img:
                img.verify()  # Check file integrity
                img.close()  # Ensure file is closed
                # Reopen to check format compatibility
                with Image.open(file_path) as img:
                    img = img.convert("RGB")  # Normalize to RGB
        except UnidentifiedImageError:
            os.remove(file_path)
            raise HTTPException(
                status_code=400,
                detail="Uploaded file is not a valid image. Ensure it's a valid JPG or PNG."
            )

        return str(file_path.absolute())

    except HTTPException:
        raise
    except Exception as e:
        # Log specific error for debugging
        print(f"[ImageService] Failed to save uploaded image: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to save uploaded image: {str(e)}"
        )
    
def ask_gemini_with_image(prompt: str, image_path: str) -> str:
    """
    Send an image along with a text prompt to Gemini for visual analysis or description.

    Args:
        prompt (str): The user's question or instruction about the image.
        image_path (str): Path to the uploaded image file (JPG/PNG).

    Returns:
        str: The response generated by Gemini based on the image and prompt.
    """
    try:
        # ✅ Check if the image file exists
        if not os.path.exists(image_path):
            return f"❌ Image not found: {image_path}"

        # ✅ Open and normalize the image
        with Image.open(image_path) as img:
            img = img.convert("RGB")  # Normalize to RGB

        # ✅ Send prompt and image to Gemini
        model = get_model()
        full_prompt = f"Analyze the provided image and answer the following question clearly referencing the image: {prompt}"
        response = model.generate_content([full_prompt, img])
        return response.text.strip() if response and response.text else "(No response from Gemini)"

    except Exception as e:
        print(f"[GeminiService] Image query failed: {e}")
        return f"❌ Error while analyzing image: {e}"

    
async def ask_gemini_with_image_streaming(prompt: str, image_path: str):
    """
    Send an image along with a text prompt to Gemini with streaming.

    Args:
        prompt (str): The user's question or instruction about the image.
        image_path (str): Path to the uploaded image file (JPG/PNG).

    Yields:
        str: Each chunk of the generated text from Gemini.
    """
    try:
        if not os.path.exists(image_path):
            yield f"❌ Image not found: {image_path}"
            return

        with Image.open(image_path) as img:
            img = img.convert("RGB")

        model = get_model()
        full_prompt = f"Analyze the provided image and answer the following question clearly referencing the image: {prompt}"
        response = model.generate_content([full_prompt, img], stream=True)
        for chunk in response:
            if chunk.text:
                yield chunk.text.strip()  # Yield each chunk
    except Exception as e:
        print(f"[ImageService] Image streaming query failed: {e}")
        yield f"❌ Error while analyzing image: {e}"